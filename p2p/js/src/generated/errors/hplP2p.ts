/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/kinobi-so/kinobi
 */

import type { Program } from "@metaplex-foundation/umi";

import { ProgramError } from "@metaplex-foundation/umi";

type ProgramErrorConstructor = new (program: Program, cause?: Error) => ProgramError;
const codeToErrorMap = new Map<number, ProgramErrorConstructor>();
const nameToErrorMap = new Map<string, ProgramErrorConstructor>();

/** DeserializationError: Failed to deserialize account */
export class DeserializationErrorError extends ProgramError {
  override readonly name: string = "DeserializationError";

  readonly code: number = 0x0; // 0

  constructor(program: Program, cause?: Error) {
    super("Failed to deserialize account", program, cause);
  }
}
codeToErrorMap.set(0x0, DeserializationErrorError);
nameToErrorMap.set("DeserializationError", DeserializationErrorError);

/** SerializationError: Failed to serialize account */
export class SerializationErrorError extends ProgramError {
  override readonly name: string = "SerializationError";

  readonly code: number = 0x1; // 1

  constructor(program: Program, cause?: Error) {
    super("Failed to serialize account", program, cause);
  }
}
codeToErrorMap.set(0x1, SerializationErrorError);
nameToErrorMap.set("SerializationError", SerializationErrorError);

/** MarketClosed: Market is closed */
export class MarketClosedError extends ProgramError {
  override readonly name: string = "MarketClosed";

  readonly code: number = 0x2; // 2

  constructor(program: Program, cause?: Error) {
    super("Market is closed", program, cause);
  }
}
codeToErrorMap.set(0x2, MarketClosedError);
nameToErrorMap.set("MarketClosed", MarketClosedError);

/** MarketNotResolved: Market is not resolved */
export class MarketNotResolvedError extends ProgramError {
  override readonly name: string = "MarketNotResolved";

  readonly code: number = 0x3; // 3

  constructor(program: Program, cause?: Error) {
    super("Market is not resolved", program, cause);
  }
}
codeToErrorMap.set(0x3, MarketNotResolvedError);
nameToErrorMap.set("MarketNotResolved", MarketNotResolvedError);

/** MarketAlreadyResolved: Market already resolved */
export class MarketAlreadyResolvedError extends ProgramError {
  override readonly name: string = "MarketAlreadyResolved";

  readonly code: number = 0x4; // 4

  constructor(program: Program, cause?: Error) {
    super("Market already resolved", program, cause);
  }
}
codeToErrorMap.set(0x4, MarketAlreadyResolvedError);
nameToErrorMap.set("MarketAlreadyResolved", MarketAlreadyResolvedError);

/** MarketNotInvalid: Market is not invalid */
export class MarketNotInvalidError extends ProgramError {
  override readonly name: string = "MarketNotInvalid";

  readonly code: number = 0x5; // 5

  constructor(program: Program, cause?: Error) {
    super("Market is not invalid", program, cause);
  }
}
codeToErrorMap.set(0x5, MarketNotInvalidError);
nameToErrorMap.set("MarketNotInvalid", MarketNotInvalidError);

/** MarketNotYes: Market is not resolved yes */
export class MarketNotYesError extends ProgramError {
  override readonly name: string = "MarketNotYes";

  readonly code: number = 0x6; // 6

  constructor(program: Program, cause?: Error) {
    super("Market is not resolved yes", program, cause);
  }
}
codeToErrorMap.set(0x6, MarketNotYesError);
nameToErrorMap.set("MarketNotYes", MarketNotYesError);

/** MarketNotNo: Market is not resolved yes */
export class MarketNotNoError extends ProgramError {
  override readonly name: string = "MarketNotNo";

  readonly code: number = 0x7; // 7

  constructor(program: Program, cause?: Error) {
    super("Market is not resolved yes", program, cause);
  }
}
codeToErrorMap.set(0x7, MarketNotNoError);
nameToErrorMap.set("MarketNotNo", MarketNotNoError);

/** AlreadyClaimed: Already claimed */
export class AlreadyClaimedError extends ProgramError {
  override readonly name: string = "AlreadyClaimed";

  readonly code: number = 0x8; // 8

  constructor(program: Program, cause?: Error) {
    super("Already claimed", program, cause);
  }
}
codeToErrorMap.set(0x8, AlreadyClaimedError);
nameToErrorMap.set("AlreadyClaimed", AlreadyClaimedError);

/** InvalidBps: Invalid basis points value */
export class InvalidBpsError extends ProgramError {
  override readonly name: string = "InvalidBps";

  readonly code: number = 0x9; // 9

  constructor(program: Program, cause?: Error) {
    super("Invalid basis points value", program, cause);
  }
}
codeToErrorMap.set(0x9, InvalidBpsError);
nameToErrorMap.set("InvalidBps", InvalidBpsError);

/** InvalidCloseTimestamp: Close timestamp is in the past */
export class InvalidCloseTimestampError extends ProgramError {
  override readonly name: string = "InvalidCloseTimestamp";

  readonly code: number = 0xa; // 10

  constructor(program: Program, cause?: Error) {
    super("Close timestamp is in the past", program, cause);
  }
}
codeToErrorMap.set(0xa, InvalidCloseTimestampError);
nameToErrorMap.set("InvalidCloseTimestamp", InvalidCloseTimestampError);

/** ConfigAuthorityMismatch: Authority address does not match config authority */
export class ConfigAuthorityMismatchError extends ProgramError {
  override readonly name: string = "ConfigAuthorityMismatch";

  readonly code: number = 0xb; // 11

  constructor(program: Program, cause?: Error) {
    super("Authority address does not match config authority", program, cause);
  }
}
codeToErrorMap.set(0xb, ConfigAuthorityMismatchError);
nameToErrorMap.set("ConfigAuthorityMismatch", ConfigAuthorityMismatchError);

/** MarketMintMismatch: Mint address does not match market mint */
export class MarketMintMismatchError extends ProgramError {
  override readonly name: string = "MarketMintMismatch";

  readonly code: number = 0xc; // 12

  constructor(program: Program, cause?: Error) {
    super("Mint address does not match market mint", program, cause);
  }
}
codeToErrorMap.set(0xc, MarketMintMismatchError);
nameToErrorMap.set("MarketMintMismatch", MarketMintMismatchError);

/** MarketResolverMismatch: Resolver address does not match market resolver */
export class MarketResolverMismatchError extends ProgramError {
  override readonly name: string = "MarketResolverMismatch";

  readonly code: number = 0xd; // 13

  constructor(program: Program, cause?: Error) {
    super("Resolver address does not match market resolver", program, cause);
  }
}
codeToErrorMap.set(0xd, MarketResolverMismatchError);
nameToErrorMap.set("MarketResolverMismatch", MarketResolverMismatchError);

/** MarketCreatorMismatch: Wallet address does not match market creator */
export class MarketCreatorMismatchError extends ProgramError {
  override readonly name: string = "MarketCreatorMismatch";

  readonly code: number = 0xe; // 14

  constructor(program: Program, cause?: Error) {
    super("Wallet address does not match market creator", program, cause);
  }
}
codeToErrorMap.set(0xe, MarketCreatorMismatchError);
nameToErrorMap.set("MarketCreatorMismatch", MarketCreatorMismatchError);

/** PositionWalletMismatch: Wallet address does not match position wallet */
export class PositionWalletMismatchError extends ProgramError {
  override readonly name: string = "PositionWalletMismatch";

  readonly code: number = 0xf; // 15

  constructor(program: Program, cause?: Error) {
    super("Wallet address does not match position wallet", program, cause);
  }
}
codeToErrorMap.set(0xf, PositionWalletMismatchError);
nameToErrorMap.set("PositionWalletMismatch", PositionWalletMismatchError);

/** InvalidPositionMultiple: Position amount is not a multiple of opposing odds */
export class InvalidPositionMultipleError extends ProgramError {
  override readonly name: string = "InvalidPositionMultiple";

  readonly code: number = 0x10; // 16

  constructor(program: Program, cause?: Error) {
    super("Position amount is not a multiple of opposing odds", program, cause);
  }
}
codeToErrorMap.set(0x10, InvalidPositionMultipleError);
nameToErrorMap.set("InvalidPositionMultiple", InvalidPositionMultipleError);

/** InsufficientOpposingPosition: Insufficient opposing position for position amount */
export class InsufficientOpposingPositionError extends ProgramError {
  override readonly name: string = "InsufficientOpposingPosition";

  readonly code: number = 0x11; // 17

  constructor(program: Program, cause?: Error) {
    super("Insufficient opposing position for position amount", program, cause);
  }
}
codeToErrorMap.set(0x11, InsufficientOpposingPositionError);
nameToErrorMap.set("InsufficientOpposingPosition", InsufficientOpposingPositionError);

/** ResolveTooEarly: Market resolve timestamp has not been reached */
export class ResolveTooEarlyError extends ProgramError {
  override readonly name: string = "ResolveTooEarly";

  readonly code: number = 0x12; // 18

  constructor(program: Program, cause?: Error) {
    super("Market resolve timestamp has not been reached", program, cause);
  }
}
codeToErrorMap.set(0x12, ResolveTooEarlyError);
nameToErrorMap.set("ResolveTooEarly", ResolveTooEarlyError);

/** CloseTimestampInPast: Close timestamp is in the past */
export class CloseTimestampInPastError extends ProgramError {
  override readonly name: string = "CloseTimestampInPast";

  readonly code: number = 0x13; // 19

  constructor(program: Program, cause?: Error) {
    super("Close timestamp is in the past", program, cause);
  }
}
codeToErrorMap.set(0x13, CloseTimestampInPastError);
nameToErrorMap.set("CloseTimestampInPast", CloseTimestampInPastError);

/** ResolveTimestampBeforeClose: Resolve timestamp is before the close timestamp */
export class ResolveTimestampBeforeCloseError extends ProgramError {
  override readonly name: string = "ResolveTimestampBeforeClose";

  readonly code: number = 0x14; // 20

  constructor(program: Program, cause?: Error) {
    super("Resolve timestamp is before the close timestamp", program, cause);
  }
}
codeToErrorMap.set(0x14, ResolveTimestampBeforeCloseError);
nameToErrorMap.set("ResolveTimestampBeforeClose", ResolveTimestampBeforeCloseError);

/** MarketHasPositions: Market with opposing positions cannot be closed */
export class MarketHasPositionsError extends ProgramError {
  override readonly name: string = "MarketHasPositions";

  readonly code: number = 0x15; // 21

  constructor(program: Program, cause?: Error) {
    super("Market with opposing positions cannot be closed", program, cause);
  }
}
codeToErrorMap.set(0x15, MarketHasPositionsError);
nameToErrorMap.set("MarketHasPositions", MarketHasPositionsError);

/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 */
export function getHplP2pErrorFromCode(
  code: number,
  program: Program,
  cause?: Error,
): ProgramError | null {
  const constructor = codeToErrorMap.get(code);
  return constructor ? new constructor(program, cause) : null;
}

/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 */
export function getHplP2pErrorFromName(
  name: string,
  program: Program,
  cause?: Error,
): ProgramError | null {
  const constructor = nameToErrorMap.get(name);
  return constructor ? new constructor(program, cause) : null;
}
